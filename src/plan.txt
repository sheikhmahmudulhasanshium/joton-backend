there will be non tech users so using email is not ideal. recieptionist /admin will ask for name, age, gender, phone number, blood group, complaint/disease, doctor name,reference,last visited at,using existing prescription etc to create a serial token. patient will visit doctor. doctor will prescribe medicine from the pharmacy, suggest test from lab if needed and follow up date. user will pay in register. do lab checkup , recieve result , forward to doctor for followup, buy medicine. every staff will be paid according to contract. invoices like blood bANK, pharmacy will be checked. every employess action will be monitored by owner. there will be insurance companies,lAWYERS for   EMERGENCIES . So these whole ecosystem will be handled by the system. now suggest approppriate system and configuration.
Excellent. You've provided all the necessary context. The key is to reconcile your previous code structure with the new, more sophisticated "Identity vs. Account" architecture. The old schema you provided is now superseded by the new one.

Here is the full, detailed, step-by-step plan in text format. This is your master checklist. We will build this logically, from the ground up, ensuring a stable and scalable system.

HMS Backend Development Plan v3.0

Guiding Principles:

Identity First, Account Second: The system is built around patient and staff profiles. Login is an optional layer.

Backend-Driven Logic: All business rules, ID generation, and state changes are handled by the NestJS backend, making the frontend a "dumb" client.

Modular & Scalable: Each core function (patients, staff, encounters) will be its own NestJS module.

Security by Design: All actions are authenticated, authorized by role, and logged for auditing.

Phase 1: Foundation & Identity Core (The Most Critical Phase)

Goal: Establish the new data model and the fundamental separation of identity and accounts. At the end of this phase, you can't log in yet, but you can create patient and staff records.

Checklist:

1.1. Project Initialization:

Start a fresh NestJS project.

Install initial dependencies: @nestjs/config, @nestjs/mongoose, mongoose, class-validator, class-transformer, helmet, bcrypt.

1.2. New Folder Structure:

Create a new, more modular folder structure:

code
Code
download
content_copy
expand_less

src/
├── app.module.ts
├── main.ts
├── common/ (guards, decorators, enums)
├── config/ (database, jwt configs)
├── modules/
│   ├── auth/
│   ├── users/ (the login accounts)
│   ├── patients/
│   ├── staff/
│   └── core/ (shared services like ID generation)

1.3. Implement Core Schemas (No Logic Yet):

Create the Mongoose schema file for patient_profiles.

Create the Mongoose schema file for staff_profiles.

Create the Mongoose schema file for users (the new version with identityId).

1.4. Implement Core Services:

Create a core.service.ts in the core module.

Implement a function generatePatientId() that creates a unique, human-readable ID (e.g., JHMS-2024-00001).

Implement a function generateStaffId() (e.g., EMP-00123).

1.5. Build the Patients Module:

Create patients.module.ts, patients.service.ts, patients.controller.ts.

In patients.service.ts, create the registerNewPatient() method. This method will:

Take DTO with firstName, lastName, phone, dob, etc.

Call the core.service to get a new patientId.

Save the new patient profile to the patient_profiles collection.

Crucially, it does NOT create a users account.

Create the POST /patients/register endpoint in the controller for the receptionist.

1.6. Build the Staff Module:

Create staff.module.ts, staff.service.ts, staff.controller.ts.

In staff.service.ts, create the createNewStaffMember() method (initially, this just creates the profile, not the login).

Create the POST /staff endpoint for an Admin/HR to create a staff record.

Phase 2: Authentication & Authorization Layer

Goal: Build the login system on top of the established identity layer. At the end of this phase, staff can be invited and can log in to the system.

Checklist:

2.1. Dependency Installation:

pnpm add @nestjs/passport passport passport-jwt @nestjs/jwt cookie-parser

pnpm add -D @types/passport-jwt @types/cookie-parser

2.2. Implement the Users Module:

Create users.module.ts, users.service.ts. No controller is needed as users are managed via the Auth/Staff modules.

The users.service.ts will have internal methods like createUserAccount(), findUserByEmail(), etc.

2.3. Build the Staff Invitation Flow:

Add a method inviteStaffMember(staffId: string) to staff.service.ts. This method will:

Find the staff profile by its ID.

Call users.service.ts to create a new users account, linking it with the staff_profile's _id as the identityId.

Generate a temporary, single-use token for setting a password.

(Later) Send an invitation email with a link like frontend.com/invite?token=....

2.4. Build the Auth Module (The Renovation):

Implement the full HttpOnly cookie-based login/refresh/logout flow as we designed.

The auth.service.ts's validateUser will now check the users collection.

The JWT payload must include identityId and identityType in addition to userId and role. This is critical for fetching the correct profile information.

Create the POST /auth/set-password endpoint that validates the invitation token and sets the user's initial password.

2.5. Implement Global Guards:

Configure the JwtAccessGuard to be global, as planned.

Use the @Public() decorator on public endpoints like /auth/login.

Create the RolesGuard for permission control.

Phase 3: The Clinical Workflow (First End-to-End Feature)

Goal: Implement the core "patient visit" flow, from check-in to prescription. This proves the entire architecture works together.

Checklist:

3.1. Build the Encounters Module:

Create the encounters schema, module, service, and controller.

Create the POST /encounters/check-in endpoint. It takes a patientId and chiefComplaint. This is used by the Receptionist.

It creates an Encounter document with status: 'CheckedIn' and returns the encounterId (the "serial token").

3.2. Build the Clinical Records Module:

Create the clinical_records schema, module, service, and controller.

Create the POST /clinical-records endpoint. It takes an encounterId and all the clinical data (diagnosis, prescription, etc.). This is used by the Doctor.

The service logic links the record to the encounter and the doctor who created it.

3.3. Build the Invoices Module (Basic):

Create the invoices schema, module, service, and controller.

Create a method in the InvoicesService called generateInvoiceForEncounter(encounterId: string).

This service calculates costs (e.g., consultation fee) and creates an Invoice document linked to the encounter.

3.4. Secure All Endpoints with RolesGuard:

POST /encounters/check-in: @Roles(Role.RECEPTIONIST)

POST /clinical-records: @Roles(Role.DOCTOR)

GET /patients/:id: @Roles(Role.DOCTOR, Role.RECEPTIONIST)

And so on for all new endpoints.

Phase 4: Auditing & Ecosystem Integration

Goal: Add the final layers of professional features, including monitoring and third-party management.

Checklist:

4.1. Build the Audit Log Module:

Create the audit_logs schema, module, and service.

Make the AuditLogService a global module so it can be injected anywhere.

Go back through all critical services (patients, staff, clinical_records, invoices) and add calls to this.auditLogService.log(...) at the end of key methods.

Create a GET /audit-logs endpoint protected for @Roles(Role.OWNER) only.

4.2. Build the Third Parties Module:

Create the third_parties schema, module, service, and controller.

Implement basic CRUD endpoints for managing insurance companies, law firms, etc. This is likely an Admin-only function.

This structured plan ensures you are not building features in isolation. Each phase builds logically on the last, starting with the most fundamental architectural decisions and ending with the high-level business features. This is the path from a simple login app to a genuine, robust Hospital Management System.Your Immediate To-Do List:
Build the Encounters Module: This is the "serial token" or "visit" module.
Create the schema, service, controller, and DTOs.
Implement the POST /encounters/check-in endpoint for Receptionists.
Build the Clinical Records Module:
Create the schema, service, controller, and DTOs.
Implement the POST /clinical-records endpoint for Doctors to add prescriptions, diagnoses, etc., linked to an encounterId.
Enhance the Invoices Module:
Create a service method that can automatically generate an invoice based on the services recorded in a Clinical Record (e.g., consultation fee, lab test fee).
You have successfully navigated the most complex part of the backend setup. Congratulations! You are now ready to build the core features that will bring your HMS to life.